import type { UnpluginBuildContext, UnpluginOptions } from 'unplugin'
import type { Options } from '../types.js'
import { Buffer } from 'node:buffer'
import { readFile } from 'node:fs/promises'
import { basename, dirname, join, parse, relative, resolve } from 'node:path'
import { cwd } from 'node:process'
import { xxh3 } from '@node-rs/xxhash'
import { BINARY_GLTF_MODEL_EXTENSION, JSON_LOAD_MARKER, SEPARATE_GLTF_MODEL_EXTENSION } from '../core/constants.js'
import { handleReferencedModelFiles, isGltfModelFile } from '../core/utils/find-models.js'
import { getBasePath } from './base-path.js'
import { isBuild } from './dev.js'

// TODO: Do we have to handle base paths when building file paths? Can we even get it in bundler-agnostic way?

export function loadInclude(id: string): boolean {
  // This is needed for some bundlers even though stated otherwise by the documentation...

  return isGltfModelFile(id)
}

export const createLoad: (options: Options) => UnpluginOptions['load'] = () => async function (id) {
  if (id.endsWith(BINARY_GLTF_MODEL_EXTENSION)) {
    return await loadBinaryGltfModel.call(this, id)
  }

  if (id.endsWith(SEPARATE_GLTF_MODEL_EXTENSION)) {
    return await loadSeparateGltfModel.call(this, id)
  }
}

async function loadBinaryGltfModel(this: UnpluginBuildContext, modelFile: string): Promise<{ code: string }> {
  let path: string

  if (isBuild()) {
    /*
      TODO: Parse the binary for the json contents and process them like below.
      A binary model contains one or two chunks of data. The first chunk (starting after 12 bytes) is encoded json
      which can be extracted with TextDecoder according to the spec. This json can reference external buffers or the
      embedded binary buffer which must be the second chunk.
      For now we assume that a binary model file does NOT reference external files.
    */

    // Emit the file.

    path = await emitAssetFromFile.call(this, modelFile)
  }
  else {
    // Just pass the relative path.

    path = getRelativeProjectPathToFile(modelFile)
  }

  path = join(getBasePath(), path)

  return {
    code: `export default ${JSON.stringify(path)};`,
  }
}

async function loadSeparateGltfModel(this: UnpluginBuildContext, modelFile: string): Promise<{ code: string }> {
  let path: string

  if (isBuild()) {
    // During build emit the (potentially altered) json.

    const rawGltf = JSON.parse(await readFile(modelFile, { encoding: 'utf8' }))

    await handleGltfJson.call(this, rawGltf, modelFile)

    path = emitAsset.call(this, modelFile, Buffer.from(JSON.stringify(rawGltf)))
  }
  else {
    // During dev return the original path with specifier to load it later. This prevents it from triggering the load
    // hook again.

    path = getRelativeProjectPathToFile(modelFile) + JSON_LOAD_MARKER
  }

  path = join(getBasePath(), path)

  return {
    code: `export default ${JSON.stringify(path)};`,
  }
}

async function handleGltfJson(this: UnpluginBuildContext, rawGltf: object, modelFile: string): Promise<void> {
  // The json can reference other files. We need to resolve them to other paths so the build tools can correctly resolve
  // them.
  await handleReferencedModelFiles(rawGltf, async ({ setUri, uri }) => {
    // According to the gtlf spec uri should now always be relative to the gltf file. The other allowed type
    // (embedded) is not even forwarded here from this helper function.

    const absoluteUri = resolve(dirname(modelFile), uri)

    const newUri = await emitAssetFromFile.call(this, absoluteUri)

    // Take the basename because we assume that in the end this is placed next to the main model file.

    setUri(basename(newUri))
  })
}

function getRelativeProjectPathToFile(absolutePath: string): string {
  return relative(cwd(), absolutePath)
}

async function emitAssetFromFile(this: UnpluginBuildContext, absolutePath: string): Promise<string> {
  const source = await readFile(absolutePath)

  return emitAsset.call(this, absolutePath, source)
}

function emitAsset(this: UnpluginBuildContext, originalFileName: string, source: Buffer): string {
  // Unplugin has no way to get the generated filename of an emitted file after it is generated by the bundler.
  // Because of that we hash the file ourselves and assign a fixed filename.

  const fileName = getHashedFilename(originalFileName, source)

  this.emitFile({
    fileName,
    source,
    type: 'asset',
  })

  return fileName
}

function getHashedFilename(file: string, source: Buffer): string {
  const hash = xxh3.xxh128(source).toString(16)

  const { ext, name } = parse(file)

  // TODO: Make this folder configurable?
  return `models/${name}.${hash.slice(0, 8)}${ext}`
}
