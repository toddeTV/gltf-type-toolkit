import type { Buffer } from 'node:buffer'
import type { UnpluginBuildContext, UnpluginOptions } from 'unplugin'
import type { Options } from '../types.js'
import { readFile } from 'node:fs/promises'
import { dirname, parse, resolve } from 'node:path'
import { xxh3 } from '@node-rs/xxhash'
import { BINARY_GLTF_MODEL_EXTENSION, SEPARATE_GLTF_MODEL_EXTENSION } from '../core/constants.js'
import { handleReferencedModelFiles, isGltfModelFile } from '../core/utils/find-models.js'
import { isBuild } from './dev.js'

export function loadInclude(id: string): boolean {
  // This is needed for some bundlers even though stated otherwise by the documentation...

  return isGltfModelFile(id)
}

export const createLoad: (options: Options | undefined) => UnpluginOptions['load'] = () => async function (id) {
  if (id.endsWith(BINARY_GLTF_MODEL_EXTENSION)) {
    return await loadBinaryGltfModel.call(this, id)
  }

  if (id.endsWith(SEPARATE_GLTF_MODEL_EXTENSION)) {
    return await loadSeparateGltfModel.call(this, id)
  }
}

async function loadBinaryGltfModel(this: UnpluginBuildContext, modelFile: string): Promise<{ code: string }> {
  // TODO: Parse the binary for the json contents and process them like below.
  // A binary model contains one or two chunks of data. The first chunk (starting after 12 bytes) is encoded json which
  // can be extracted with TextDecoder according to the spec. This json can reference external buffers or the embedded
  // binary buffer which must be the second chunk.
  // For now we assume that a binary model file does NOT reference external files.

  const source = await readFile(modelFile)

  return {
    // The gltf loader expects an ArrayBuffer...
    code: `export default new Uint8Array([${[...source].join(', ')}]).buffer;`,
  }
}

async function loadSeparateGltfModel(this: UnpluginBuildContext, modelFile: string): Promise<{ code: string }> {
  const rawGltf = JSON.parse(await readFile(modelFile, { encoding: 'utf8' }))

  // For dev we just want to pass the gltf json. The gltf loader of three.js should do its thing correctly and resolve
  // all referenced files.
  // During building we want to bundle those referenced files. That means the paths inside the json need to be adjusted.
  if (isBuild()) {
    await handleReferencedModelFiles(rawGltf, async ({ setUri, uri }) => {
      // According to the gtlf spec uri should now always be relative to the gltf file. The other allowed type
      // (embedded) is not even forwarded here from this helper function.

      const absoluteUri = resolve(dirname(modelFile), uri)

      const source = await readFile(absoluteUri)

      const fileName = emitAssetFile.call(this, absoluteUri, source)

      // The file name must be absolute because we want to serve it from the root.
      // TODO: Do we have to handle a base path here? Can we even get it in bundler-agnostic way?
      setUri(`/${fileName}`)
    })
  }

  return {
    code: `export default ${JSON.stringify(rawGltf)};`,
  }
}

function emitAssetFile(this: UnpluginBuildContext, originalFileName: string, source: Buffer): string {
  // Unplugin has no way to get the generated filename of an emitted file after it is generated by the bundler.
  // Because of that we hash the file ourselves and assign a fixed filename.

  const fileName = getHashedFilename(originalFileName, source)

  this.emitFile({
    fileName,
    source,
    type: 'asset',
  })

  return fileName
}

function getHashedFilename(file: string, source: Buffer): string {
  const hash = xxh3.xxh128(source).toString(16)

  const { ext, name } = parse(file)

  // TODO: Make this folder configurable?
  return `models/${name}.${hash.slice(0, 8)}${ext}`
}
